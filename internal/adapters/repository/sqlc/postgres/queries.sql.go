// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package postgresrepo

import (
	"context"
	"database/sql"
	"time"
)

const countURLsByCreatedBy = `-- name: CountURLsByCreatedBy :one
SELECT COUNT(*) as count
FROM urls
WHERE ($1 = '' OR created_by = $1)
`

// Parameters: created_by_filter (pass empty string to count all URLs)
func (q *Queries) CountURLsByCreatedBy(ctx context.Context, createdByFilter interface{}) (int64, error) {
	row := q.queryRow(ctx, q.countURLsByCreatedByStmt, countURLsByCreatedBy, createdByFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createURL = `-- name: CreateURL :one

INSERT INTO urls (short_code, original_url, created_at, created_by)
VALUES ($1, $2, $3, $4)
RETURNING id, short_code, original_url, created_at, created_by
`

type CreateURLParams struct {
	ShortCode   string    `json:"short_code"`
	OriginalUrl string    `json:"original_url"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedBy   string    `json:"created_by"`
}

// ============================================================================
// URL Queries
// ============================================================================
func (q *Queries) CreateURL(ctx context.Context, arg CreateURLParams) (Url, error) {
	row := q.queryRow(ctx, q.createURLStmt, createURL,
		arg.ShortCode,
		arg.OriginalUrl,
		arg.CreatedAt,
		arg.CreatedBy,
	)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteURLByShortCode = `-- name: DeleteURLByShortCode :exec
DELETE FROM urls
WHERE short_code = $1
`

func (q *Queries) DeleteURLByShortCode(ctx context.Context, shortCode string) error {
	_, err := q.exec(ctx, q.deleteURLByShortCodeStmt, deleteURLByShortCode, shortCode)
	return err
}

const findURLByShortCode = `-- name: FindURLByShortCode :one
SELECT id, short_code, original_url, created_at, created_by
FROM urls
WHERE short_code = $1
`

func (q *Queries) FindURLByShortCode(ctx context.Context, shortCode string) (Url, error) {
	row := q.queryRow(ctx, q.findURLByShortCodeStmt, findURLByShortCode, shortCode)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getClicksByCountry = `-- name: GetClicksByCountry :many
SELECT country, COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND country IS NOT NULL
  AND country != ''
GROUP BY country
ORDER BY count DESC
`

type GetClicksByCountryRow struct {
	Country sql.NullString `json:"country"`
	Count   int64          `json:"count"`
}

func (q *Queries) GetClicksByCountry(ctx context.Context, urlID int32) ([]GetClicksByCountryRow, error) {
	rows, err := q.query(ctx, q.getClicksByCountryStmt, getClicksByCountry, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByCountryRow{}
	for rows.Next() {
		var i GetClicksByCountryRow
		if err := rows.Scan(&i.Country, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByCountryInTimeRange = `-- name: GetClicksByCountryInTimeRange :many
SELECT country, COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND clicked_at >= $2
  AND clicked_at <= $3
  AND country IS NOT NULL
  AND country != ''
GROUP BY country
ORDER BY count DESC
`

type GetClicksByCountryInTimeRangeParams struct {
	UrlID       int32     `json:"url_id"`
	ClickedAt   time.Time `json:"clicked_at"`
	ClickedAt_2 time.Time `json:"clicked_at_2"`
}

type GetClicksByCountryInTimeRangeRow struct {
	Country sql.NullString `json:"country"`
	Count   int64          `json:"count"`
}

func (q *Queries) GetClicksByCountryInTimeRange(ctx context.Context, arg GetClicksByCountryInTimeRangeParams) ([]GetClicksByCountryInTimeRangeRow, error) {
	rows, err := q.query(ctx, q.getClicksByCountryInTimeRangeStmt, getClicksByCountryInTimeRange, arg.UrlID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByCountryInTimeRangeRow{}
	for rows.Next() {
		var i GetClicksByCountryInTimeRangeRow
		if err := rows.Scan(&i.Country, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByDate = `-- name: GetClicksByDate :many
SELECT DATE(clicked_at) as date, COUNT(*) as count
FROM clicks
WHERE url_id = $1
GROUP BY date
ORDER BY date DESC
`

type GetClicksByDateRow struct {
	Date  time.Time `json:"date"`
	Count int64     `json:"count"`
}

func (q *Queries) GetClicksByDate(ctx context.Context, urlID int32) ([]GetClicksByDateRow, error) {
	rows, err := q.query(ctx, q.getClicksByDateStmt, getClicksByDate, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByDateRow{}
	for rows.Next() {
		var i GetClicksByDateRow
		if err := rows.Scan(&i.Date, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByReferrer = `-- name: GetClicksByReferrer :many
SELECT referrer, COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND referrer IS NOT NULL
  AND referrer != ''
GROUP BY referrer
ORDER BY count DESC
LIMIT 10
`

type GetClicksByReferrerRow struct {
	Referrer sql.NullString `json:"referrer"`
	Count    int64          `json:"count"`
}

func (q *Queries) GetClicksByReferrer(ctx context.Context, urlID int32) ([]GetClicksByReferrerRow, error) {
	rows, err := q.query(ctx, q.getClicksByReferrerStmt, getClicksByReferrer, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByReferrerRow{}
	for rows.Next() {
		var i GetClicksByReferrerRow
		if err := rows.Scan(&i.Referrer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByReferrerInTimeRange = `-- name: GetClicksByReferrerInTimeRange :many
SELECT referrer, COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND clicked_at >= $2
  AND clicked_at <= $3
  AND referrer IS NOT NULL
  AND referrer != ''
GROUP BY referrer
ORDER BY count DESC
LIMIT 10
`

type GetClicksByReferrerInTimeRangeParams struct {
	UrlID       int32     `json:"url_id"`
	ClickedAt   time.Time `json:"clicked_at"`
	ClickedAt_2 time.Time `json:"clicked_at_2"`
}

type GetClicksByReferrerInTimeRangeRow struct {
	Referrer sql.NullString `json:"referrer"`
	Count    int64          `json:"count"`
}

func (q *Queries) GetClicksByReferrerInTimeRange(ctx context.Context, arg GetClicksByReferrerInTimeRangeParams) ([]GetClicksByReferrerInTimeRangeRow, error) {
	rows, err := q.query(ctx, q.getClicksByReferrerInTimeRangeStmt, getClicksByReferrerInTimeRange, arg.UrlID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByReferrerInTimeRangeRow{}
	for rows.Next() {
		var i GetClicksByReferrerInTimeRangeRow
		if err := rows.Scan(&i.Referrer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalClickCount = `-- name: GetTotalClickCount :one
SELECT COUNT(*) as count
FROM clicks
WHERE url_id = $1
`

func (q *Queries) GetTotalClickCount(ctx context.Context, urlID int32) (int64, error) {
	row := q.queryRow(ctx, q.getTotalClickCountStmt, getTotalClickCount, urlID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalClickCountInTimeRange = `-- name: GetTotalClickCountInTimeRange :one
SELECT COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND clicked_at >= $2
  AND clicked_at <= $3
`

type GetTotalClickCountInTimeRangeParams struct {
	UrlID       int32     `json:"url_id"`
	ClickedAt   time.Time `json:"clicked_at"`
	ClickedAt_2 time.Time `json:"clicked_at_2"`
}

func (q *Queries) GetTotalClickCountInTimeRange(ctx context.Context, arg GetTotalClickCountInTimeRangeParams) (int64, error) {
	row := q.queryRow(ctx, q.getTotalClickCountInTimeRangeStmt, getTotalClickCountInTimeRange, arg.UrlID, arg.ClickedAt, arg.ClickedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listURLs = `-- name: ListURLs :many
SELECT id, short_code, original_url, created_at, created_by
FROM urls
WHERE ($1 = '' OR created_by = $2)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListURLsParams struct {
	Column1   interface{} `json:"column_1"`
	CreatedBy string      `json:"created_by"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListURLs(ctx context.Context, arg ListURLsParams) ([]Url, error) {
	rows, err := q.query(ctx, q.listURLsStmt, listURLs,
		arg.Column1,
		arg.CreatedBy,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Url{}
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listURLsByCreatedByAndTimeRange = `-- name: ListURLsByCreatedByAndTimeRange :many
SELECT id, short_code, original_url, created_at, created_by
FROM urls
WHERE created_by = $1
  AND created_at >= $2
  AND created_at <= $3
ORDER BY created_at DESC
`

type ListURLsByCreatedByAndTimeRangeParams struct {
	CreatedBy   string    `json:"created_by"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

func (q *Queries) ListURLsByCreatedByAndTimeRange(ctx context.Context, arg ListURLsByCreatedByAndTimeRangeParams) ([]Url, error) {
	rows, err := q.query(ctx, q.listURLsByCreatedByAndTimeRangeStmt, listURLsByCreatedByAndTimeRange, arg.CreatedBy, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Url{}
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordClick = `-- name: RecordClick :one

INSERT INTO clicks (url_id, clicked_at, referrer, referrer_domain, country, user_agent)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, url_id, clicked_at, referrer, referrer_domain, country, user_agent
`

type RecordClickParams struct {
	UrlID          int32          `json:"url_id"`
	ClickedAt      time.Time      `json:"clicked_at"`
	Referrer       sql.NullString `json:"referrer"`
	ReferrerDomain sql.NullString `json:"referrer_domain"`
	Country        sql.NullString `json:"country"`
	UserAgent      sql.NullString `json:"user_agent"`
}

type RecordClickRow struct {
	ID             int32          `json:"id"`
	UrlID          int32          `json:"url_id"`
	ClickedAt      time.Time      `json:"clicked_at"`
	Referrer       sql.NullString `json:"referrer"`
	ReferrerDomain sql.NullString `json:"referrer_domain"`
	Country        sql.NullString `json:"country"`
	UserAgent      sql.NullString `json:"user_agent"`
}

// ============================================================================
// Click Queries
// ============================================================================
func (q *Queries) RecordClick(ctx context.Context, arg RecordClickParams) (RecordClickRow, error) {
	row := q.queryRow(ctx, q.recordClickStmt, recordClick,
		arg.UrlID,
		arg.ClickedAt,
		arg.Referrer,
		arg.ReferrerDomain,
		arg.Country,
		arg.UserAgent,
	)
	var i RecordClickRow
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.ClickedAt,
		&i.Referrer,
		&i.ReferrerDomain,
		&i.Country,
		&i.UserAgent,
	)
	return i, err
}
