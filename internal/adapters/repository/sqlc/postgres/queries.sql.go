// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package postgresrepo

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createSession = `-- name: CreateSession :one

INSERT INTO sessions (id, user_id, created_at, expires_at, last_activity_at, ip_address, user_agent)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, created_at, expires_at, last_activity_at, ip_address, user_agent
`

type CreateSessionParams struct {
	ID             uuid.UUID      `json:"id"`
	UserID         string         `json:"user_id"`
	CreatedAt      time.Time      `json:"created_at"`
	ExpiresAt      time.Time      `json:"expires_at"`
	LastActivityAt time.Time      `json:"last_activity_at"`
	IpAddress      sql.NullString `json:"ip_address"`
	UserAgent      sql.NullString `json:"user_agent"`
}

// ============================================================================
// Session Queries
// ============================================================================
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.queryRow(ctx, q.createSessionStmt, createSession,
		arg.ID,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.LastActivityAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastActivityAt,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const createURL = `-- name: CreateURL :one

INSERT INTO urls (short_code, original_url, created_at, created_by)
VALUES ($1, $2, $3, $4)
RETURNING id, short_code, original_url, created_at, created_by
`

type CreateURLParams struct {
	ShortCode   string    `json:"short_code"`
	OriginalUrl string    `json:"original_url"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedBy   string    `json:"created_by"`
}

// ============================================================================
// URL Queries
// ============================================================================
func (q *Queries) CreateURL(ctx context.Context, arg CreateURLParams) (Url, error) {
	row := q.queryRow(ctx, q.createURLStmt, createURL,
		arg.ShortCode,
		arg.OriginalUrl,
		arg.CreatedAt,
		arg.CreatedBy,
	)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :execrows
DELETE FROM sessions
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) (int64, error) {
	result, err := q.exec(ctx, q.deleteExpiredSessionsStmt, deleteExpiredSessions)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteIdleSessions = `-- name: DeleteIdleSessions :execrows
DELETE FROM sessions
WHERE last_activity_at < $1
`

func (q *Queries) DeleteIdleSessions(ctx context.Context, lastActivityAt time.Time) (int64, error) {
	result, err := q.exec(ctx, q.deleteIdleSessionsStmt, deleteIdleSessions, lastActivityAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteSessionStmt, deleteSession, id)
	return err
}

const deleteSessionsByUserID = `-- name: DeleteSessionsByUserID :exec
DELETE FROM sessions
WHERE user_id = $1
`

func (q *Queries) DeleteSessionsByUserID(ctx context.Context, userID string) error {
	_, err := q.exec(ctx, q.deleteSessionsByUserIDStmt, deleteSessionsByUserID, userID)
	return err
}

const deleteURLByShortCode = `-- name: DeleteURLByShortCode :exec
DELETE FROM urls
WHERE short_code = $1
`

func (q *Queries) DeleteURLByShortCode(ctx context.Context, shortCode string) error {
	_, err := q.exec(ctx, q.deleteURLByShortCodeStmt, deleteURLByShortCode, shortCode)
	return err
}

const findURLByShortCode = `-- name: FindURLByShortCode :one
SELECT id, short_code, original_url, created_at, created_by
FROM urls
WHERE short_code = $1
`

func (q *Queries) FindURLByShortCode(ctx context.Context, shortCode string) (Url, error) {
	row := q.queryRow(ctx, q.findURLByShortCodeStmt, findURLByShortCode, shortCode)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getClicksByCountry = `-- name: GetClicksByCountry :many
SELECT country, COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND country IS NOT NULL
  AND country != ''
GROUP BY country
ORDER BY count DESC
`

type GetClicksByCountryRow struct {
	Country sql.NullString `json:"country"`
	Count   int64          `json:"count"`
}

func (q *Queries) GetClicksByCountry(ctx context.Context, urlID int32) ([]GetClicksByCountryRow, error) {
	rows, err := q.query(ctx, q.getClicksByCountryStmt, getClicksByCountry, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByCountryRow{}
	for rows.Next() {
		var i GetClicksByCountryRow
		if err := rows.Scan(&i.Country, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByCountryInTimeRange = `-- name: GetClicksByCountryInTimeRange :many
SELECT country, COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND clicked_at >= $2
  AND clicked_at <= $3
  AND country IS NOT NULL
  AND country != ''
GROUP BY country
ORDER BY count DESC
`

type GetClicksByCountryInTimeRangeParams struct {
	UrlID       int32     `json:"url_id"`
	ClickedAt   time.Time `json:"clicked_at"`
	ClickedAt_2 time.Time `json:"clicked_at_2"`
}

type GetClicksByCountryInTimeRangeRow struct {
	Country sql.NullString `json:"country"`
	Count   int64          `json:"count"`
}

func (q *Queries) GetClicksByCountryInTimeRange(ctx context.Context, arg GetClicksByCountryInTimeRangeParams) ([]GetClicksByCountryInTimeRangeRow, error) {
	rows, err := q.query(ctx, q.getClicksByCountryInTimeRangeStmt, getClicksByCountryInTimeRange, arg.UrlID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByCountryInTimeRangeRow{}
	for rows.Next() {
		var i GetClicksByCountryInTimeRangeRow
		if err := rows.Scan(&i.Country, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByDate = `-- name: GetClicksByDate :many
SELECT DATE(clicked_at) as date, COUNT(*) as count
FROM clicks
WHERE url_id = $1
GROUP BY date
ORDER BY date DESC
`

type GetClicksByDateRow struct {
	Date  time.Time `json:"date"`
	Count int64     `json:"count"`
}

func (q *Queries) GetClicksByDate(ctx context.Context, urlID int32) ([]GetClicksByDateRow, error) {
	rows, err := q.query(ctx, q.getClicksByDateStmt, getClicksByDate, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByDateRow{}
	for rows.Next() {
		var i GetClicksByDateRow
		if err := rows.Scan(&i.Date, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByReferrer = `-- name: GetClicksByReferrer :many
SELECT referrer, COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND referrer IS NOT NULL
  AND referrer != ''
GROUP BY referrer
ORDER BY count DESC
`

type GetClicksByReferrerRow struct {
	Referrer sql.NullString `json:"referrer"`
	Count    int64          `json:"count"`
}

func (q *Queries) GetClicksByReferrer(ctx context.Context, urlID int32) ([]GetClicksByReferrerRow, error) {
	rows, err := q.query(ctx, q.getClicksByReferrerStmt, getClicksByReferrer, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByReferrerRow{}
	for rows.Next() {
		var i GetClicksByReferrerRow
		if err := rows.Scan(&i.Referrer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByReferrerInTimeRange = `-- name: GetClicksByReferrerInTimeRange :many
SELECT referrer, COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND clicked_at >= $2
  AND clicked_at <= $3
  AND referrer IS NOT NULL
  AND referrer != ''
GROUP BY referrer
ORDER BY count DESC
`

type GetClicksByReferrerInTimeRangeParams struct {
	UrlID       int32     `json:"url_id"`
	ClickedAt   time.Time `json:"clicked_at"`
	ClickedAt_2 time.Time `json:"clicked_at_2"`
}

type GetClicksByReferrerInTimeRangeRow struct {
	Referrer sql.NullString `json:"referrer"`
	Count    int64          `json:"count"`
}

func (q *Queries) GetClicksByReferrerInTimeRange(ctx context.Context, arg GetClicksByReferrerInTimeRangeParams) ([]GetClicksByReferrerInTimeRangeRow, error) {
	rows, err := q.query(ctx, q.getClicksByReferrerInTimeRangeStmt, getClicksByReferrerInTimeRange, arg.UrlID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByReferrerInTimeRangeRow{}
	for rows.Next() {
		var i GetClicksByReferrerInTimeRangeRow
		if err := rows.Scan(&i.Referrer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, created_at, expires_at, last_activity_at, ip_address, user_agent
FROM sessions
WHERE id = $1
`

func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.queryRow(ctx, q.getSessionByIDStmt, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastActivityAt,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const getTotalClickCount = `-- name: GetTotalClickCount :one
SELECT COUNT(*) as count
FROM clicks
WHERE url_id = $1
`

func (q *Queries) GetTotalClickCount(ctx context.Context, urlID int32) (int64, error) {
	row := q.queryRow(ctx, q.getTotalClickCountStmt, getTotalClickCount, urlID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalClickCountInTimeRange = `-- name: GetTotalClickCountInTimeRange :one
SELECT COUNT(*) as count
FROM clicks
WHERE url_id = $1
  AND clicked_at >= $2
  AND clicked_at <= $3
`

type GetTotalClickCountInTimeRangeParams struct {
	UrlID       int32     `json:"url_id"`
	ClickedAt   time.Time `json:"clicked_at"`
	ClickedAt_2 time.Time `json:"clicked_at_2"`
}

func (q *Queries) GetTotalClickCountInTimeRange(ctx context.Context, arg GetTotalClickCountInTimeRangeParams) (int64, error) {
	row := q.queryRow(ctx, q.getTotalClickCountInTimeRangeStmt, getTotalClickCountInTimeRange, arg.UrlID, arg.ClickedAt, arg.ClickedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listSessionsByUserID = `-- name: ListSessionsByUserID :many
SELECT id, user_id, created_at, expires_at, last_activity_at, ip_address, user_agent
FROM sessions
WHERE user_id = $1
ORDER BY last_activity_at DESC
`

func (q *Queries) ListSessionsByUserID(ctx context.Context, userID string) ([]Session, error) {
	rows, err := q.query(ctx, q.listSessionsByUserIDStmt, listSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.LastActivityAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listURLs = `-- name: ListURLs :many
SELECT id, short_code, original_url, created_at, created_by
FROM urls
WHERE ($1 = '' OR created_by = $2)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListURLsParams struct {
	Column1   interface{} `json:"column_1"`
	CreatedBy string      `json:"created_by"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListURLs(ctx context.Context, arg ListURLsParams) ([]Url, error) {
	rows, err := q.query(ctx, q.listURLsStmt, listURLs,
		arg.Column1,
		arg.CreatedBy,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Url{}
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listURLsByCreatedByAndTimeRange = `-- name: ListURLsByCreatedByAndTimeRange :many
SELECT id, short_code, original_url, created_at, created_by
FROM urls
WHERE created_by = $1
  AND created_at >= $2
  AND created_at <= $3
ORDER BY created_at DESC
`

type ListURLsByCreatedByAndTimeRangeParams struct {
	CreatedBy   string    `json:"created_by"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

func (q *Queries) ListURLsByCreatedByAndTimeRange(ctx context.Context, arg ListURLsByCreatedByAndTimeRangeParams) ([]Url, error) {
	rows, err := q.query(ctx, q.listURLsByCreatedByAndTimeRangeStmt, listURLsByCreatedByAndTimeRange, arg.CreatedBy, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Url{}
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordClick = `-- name: RecordClick :one

INSERT INTO clicks (url_id, clicked_at, referrer, country, user_agent)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, url_id, clicked_at, referrer, country, user_agent
`

type RecordClickParams struct {
	UrlID     int32          `json:"url_id"`
	ClickedAt time.Time      `json:"clicked_at"`
	Referrer  sql.NullString `json:"referrer"`
	Country   sql.NullString `json:"country"`
	UserAgent sql.NullString `json:"user_agent"`
}

// ============================================================================
// Click Queries
// ============================================================================
func (q *Queries) RecordClick(ctx context.Context, arg RecordClickParams) (Click, error) {
	row := q.queryRow(ctx, q.recordClickStmt, recordClick,
		arg.UrlID,
		arg.ClickedAt,
		arg.Referrer,
		arg.Country,
		arg.UserAgent,
	)
	var i Click
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.ClickedAt,
		&i.Referrer,
		&i.Country,
		&i.UserAgent,
	)
	return i, err
}

const updateSessionActivity = `-- name: UpdateSessionActivity :exec
UPDATE sessions
SET last_activity_at = $1
WHERE id = $2
`

type UpdateSessionActivityParams struct {
	LastActivityAt time.Time `json:"last_activity_at"`
	ID             uuid.UUID `json:"id"`
}

func (q *Queries) UpdateSessionActivity(ctx context.Context, arg UpdateSessionActivityParams) error {
	_, err := q.exec(ctx, q.updateSessionActivityStmt, updateSessionActivity, arg.LastActivityAt, arg.ID)
	return err
}
