// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqliterepo

import (
	"context"
	"time"
)

const countURLs = `-- name: CountURLs :one
SELECT COUNT(*) as count
FROM urls
`

func (q *Queries) CountURLs(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countURLsStmt, countURLs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countURLsByCreatedBy = `-- name: CountURLsByCreatedBy :one
SELECT COUNT(*) as count
FROM urls
WHERE created_by = ?
`

func (q *Queries) CountURLsByCreatedBy(ctx context.Context, createdBy string) (int64, error) {
	row := q.queryRow(ctx, q.countURLsByCreatedByStmt, countURLsByCreatedBy, createdBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createURL = `-- name: CreateURL :one

INSERT INTO urls (short_code, original_url, created_at, created_by)
VALUES (?, ?, ?, ?)
RETURNING id, short_code, original_url, created_at, created_by
`

type CreateURLParams struct {
	ShortCode   string    `json:"short_code"`
	OriginalUrl string    `json:"original_url"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedBy   string    `json:"created_by"`
}

// ============================================================================
// URL Queries
// ============================================================================
func (q *Queries) CreateURL(ctx context.Context, arg CreateURLParams) (Url, error) {
	row := q.queryRow(ctx, q.createURLStmt, createURL,
		arg.ShortCode,
		arg.OriginalUrl,
		arg.CreatedAt,
		arg.CreatedBy,
	)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteURLByShortCode = `-- name: DeleteURLByShortCode :exec
DELETE FROM urls
WHERE short_code = ?
`

func (q *Queries) DeleteURLByShortCode(ctx context.Context, shortCode string) error {
	_, err := q.exec(ctx, q.deleteURLByShortCodeStmt, deleteURLByShortCode, shortCode)
	return err
}

const findURLByShortCode = `-- name: FindURLByShortCode :one
SELECT id, short_code, original_url, created_at, created_by
FROM urls
WHERE short_code = ?
`

func (q *Queries) FindURLByShortCode(ctx context.Context, shortCode string) (Url, error) {
	row := q.queryRow(ctx, q.findURLByShortCodeStmt, findURLByShortCode, shortCode)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getClicksByCountry = `-- name: GetClicksByCountry :many
SELECT country, COUNT(*) as count
FROM clicks
WHERE url_id = ?
  AND country IS NOT NULL
  AND country != ''
GROUP BY country
ORDER BY count DESC
`

type GetClicksByCountryRow struct {
	Country *string `json:"country"`
	Count   int64   `json:"count"`
}

func (q *Queries) GetClicksByCountry(ctx context.Context, urlID int64) ([]GetClicksByCountryRow, error) {
	rows, err := q.query(ctx, q.getClicksByCountryStmt, getClicksByCountry, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByCountryRow{}
	for rows.Next() {
		var i GetClicksByCountryRow
		if err := rows.Scan(&i.Country, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByCountryInTimeRange = `-- name: GetClicksByCountryInTimeRange :many
SELECT country, COUNT(*) as count
FROM clicks
WHERE url_id = ?
  AND clicked_at >= ?
  AND clicked_at <= ?
  AND country IS NOT NULL
  AND country != ''
GROUP BY country
ORDER BY count DESC
`

type GetClicksByCountryInTimeRangeParams struct {
	UrlID       int64     `json:"url_id"`
	ClickedAt   time.Time `json:"clicked_at"`
	ClickedAt_2 time.Time `json:"clicked_at_2"`
}

type GetClicksByCountryInTimeRangeRow struct {
	Country *string `json:"country"`
	Count   int64   `json:"count"`
}

func (q *Queries) GetClicksByCountryInTimeRange(ctx context.Context, arg GetClicksByCountryInTimeRangeParams) ([]GetClicksByCountryInTimeRangeRow, error) {
	rows, err := q.query(ctx, q.getClicksByCountryInTimeRangeStmt, getClicksByCountryInTimeRange, arg.UrlID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByCountryInTimeRangeRow{}
	for rows.Next() {
		var i GetClicksByCountryInTimeRangeRow
		if err := rows.Scan(&i.Country, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByDate = `-- name: GetClicksByDate :many
SELECT CAST(DATE(clicked_at) AS TEXT) as date, COUNT(*) as count
FROM clicks
WHERE url_id = ?
GROUP BY date
ORDER BY date DESC
`

type GetClicksByDateRow struct {
	Date  string `json:"date"`
	Count int64  `json:"count"`
}

func (q *Queries) GetClicksByDate(ctx context.Context, urlID int64) ([]GetClicksByDateRow, error) {
	rows, err := q.query(ctx, q.getClicksByDateStmt, getClicksByDate, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByDateRow{}
	for rows.Next() {
		var i GetClicksByDateRow
		if err := rows.Scan(&i.Date, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByReferrer = `-- name: GetClicksByReferrer :many
SELECT referrer, COUNT(*) as count
FROM clicks
WHERE url_id = ?
  AND referrer IS NOT NULL
  AND referrer != ''
GROUP BY referrer
ORDER BY count DESC
LIMIT 10
`

type GetClicksByReferrerRow struct {
	Referrer *string `json:"referrer"`
	Count    int64   `json:"count"`
}

func (q *Queries) GetClicksByReferrer(ctx context.Context, urlID int64) ([]GetClicksByReferrerRow, error) {
	rows, err := q.query(ctx, q.getClicksByReferrerStmt, getClicksByReferrer, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByReferrerRow{}
	for rows.Next() {
		var i GetClicksByReferrerRow
		if err := rows.Scan(&i.Referrer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClicksByReferrerInTimeRange = `-- name: GetClicksByReferrerInTimeRange :many
SELECT referrer, COUNT(*) as count
FROM clicks
WHERE url_id = ?
  AND clicked_at >= ?
  AND clicked_at <= ?
  AND referrer IS NOT NULL
  AND referrer != ''
GROUP BY referrer
ORDER BY count DESC
LIMIT 10
`

type GetClicksByReferrerInTimeRangeParams struct {
	UrlID       int64     `json:"url_id"`
	ClickedAt   time.Time `json:"clicked_at"`
	ClickedAt_2 time.Time `json:"clicked_at_2"`
}

type GetClicksByReferrerInTimeRangeRow struct {
	Referrer *string `json:"referrer"`
	Count    int64   `json:"count"`
}

func (q *Queries) GetClicksByReferrerInTimeRange(ctx context.Context, arg GetClicksByReferrerInTimeRangeParams) ([]GetClicksByReferrerInTimeRangeRow, error) {
	rows, err := q.query(ctx, q.getClicksByReferrerInTimeRangeStmt, getClicksByReferrerInTimeRange, arg.UrlID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClicksByReferrerInTimeRangeRow{}
	for rows.Next() {
		var i GetClicksByReferrerInTimeRangeRow
		if err := rows.Scan(&i.Referrer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalClickCount = `-- name: GetTotalClickCount :one
SELECT COUNT(*) as count
FROM clicks
WHERE url_id = ?
`

func (q *Queries) GetTotalClickCount(ctx context.Context, urlID int64) (int64, error) {
	row := q.queryRow(ctx, q.getTotalClickCountStmt, getTotalClickCount, urlID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalClickCountInTimeRange = `-- name: GetTotalClickCountInTimeRange :one
SELECT COUNT(*) as count
FROM clicks
WHERE url_id = ?
  AND clicked_at >= ?
  AND clicked_at <= ?
`

type GetTotalClickCountInTimeRangeParams struct {
	UrlID       int64     `json:"url_id"`
	ClickedAt   time.Time `json:"clicked_at"`
	ClickedAt_2 time.Time `json:"clicked_at_2"`
}

func (q *Queries) GetTotalClickCountInTimeRange(ctx context.Context, arg GetTotalClickCountInTimeRangeParams) (int64, error) {
	row := q.queryRow(ctx, q.getTotalClickCountInTimeRangeStmt, getTotalClickCountInTimeRange, arg.UrlID, arg.ClickedAt, arg.ClickedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getURLStatusByURLID = `-- name: GetURLStatusByURLID :one

SELECT url_id, last_checked_at, last_status_code, gone_at, archive_url, archive_checked_at
FROM url_status
WHERE url_id = ?
`

// ============================================================================
// URL Status Queries
// ============================================================================
func (q *Queries) GetURLStatusByURLID(ctx context.Context, urlID int64) (UrlStatus, error) {
	row := q.queryRow(ctx, q.getURLStatusByURLIDStmt, getURLStatusByURLID, urlID)
	var i UrlStatus
	err := row.Scan(
		&i.UrlID,
		&i.LastCheckedAt,
		&i.LastStatusCode,
		&i.GoneAt,
		&i.ArchiveUrl,
		&i.ArchiveCheckedAt,
	)
	return i, err
}

const listAllURLs = `-- name: ListAllURLs :many
SELECT id, short_code, original_url, created_at, created_by
FROM urls
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAllURLsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListAllURLs(ctx context.Context, arg ListAllURLsParams) ([]Url, error) {
	rows, err := q.query(ctx, q.listAllURLsStmt, listAllURLs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Url{}
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listURLs = `-- name: ListURLs :many
SELECT id, short_code, original_url, created_at, created_by
FROM urls
WHERE created_by = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListURLsParams struct {
	CreatedBy string `json:"created_by"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) ListURLs(ctx context.Context, arg ListURLsParams) ([]Url, error) {
	rows, err := q.query(ctx, q.listURLsStmt, listURLs, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Url{}
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listURLsByCreatedByAndTimeRange = `-- name: ListURLsByCreatedByAndTimeRange :many
SELECT id, short_code, original_url, created_at, created_by
FROM urls
WHERE created_by = ?
  AND created_at >= ?
  AND created_at <= ?
ORDER BY created_at DESC
`

type ListURLsByCreatedByAndTimeRangeParams struct {
	CreatedBy   string    `json:"created_by"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

func (q *Queries) ListURLsByCreatedByAndTimeRange(ctx context.Context, arg ListURLsByCreatedByAndTimeRangeParams) ([]Url, error) {
	rows, err := q.query(ctx, q.listURLsByCreatedByAndTimeRangeStmt, listURLsByCreatedByAndTimeRange, arg.CreatedBy, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Url{}
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listURLsDueForStatusCheck = `-- name: ListURLsDueForStatusCheck :many
SELECT
    u.id AS url_id,
    u.short_code,
    u.original_url,
    us.last_checked_at,
    us.last_status_code,
    us.gone_at,
    us.archive_url,
    us.archive_checked_at
FROM urls u
LEFT JOIN url_status us ON us.url_id = u.id
WHERE us.last_checked_at IS NULL
   OR (us.gone_at IS NULL AND us.last_checked_at <= ?)
   OR (us.gone_at IS NOT NULL AND us.last_checked_at <= ?)
ORDER BY COALESCE(us.last_checked_at, u.created_at) ASC
LIMIT ?
`

type ListURLsDueForStatusCheckParams struct {
	LastCheckedAt   *time.Time `json:"last_checked_at"`
	LastCheckedAt_2 *time.Time `json:"last_checked_at_2"`
	Limit           int64      `json:"limit"`
}

type ListURLsDueForStatusCheckRow struct {
	UrlID            int64      `json:"url_id"`
	ShortCode        string     `json:"short_code"`
	OriginalUrl      string     `json:"original_url"`
	LastCheckedAt    *time.Time `json:"last_checked_at"`
	LastStatusCode   *int64     `json:"last_status_code"`
	GoneAt           *time.Time `json:"gone_at"`
	ArchiveUrl       *string    `json:"archive_url"`
	ArchiveCheckedAt *time.Time `json:"archive_checked_at"`
}

func (q *Queries) ListURLsDueForStatusCheck(ctx context.Context, arg ListURLsDueForStatusCheckParams) ([]ListURLsDueForStatusCheckRow, error) {
	rows, err := q.query(ctx, q.listURLsDueForStatusCheckStmt, listURLsDueForStatusCheck, arg.LastCheckedAt, arg.LastCheckedAt_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListURLsDueForStatusCheckRow{}
	for rows.Next() {
		var i ListURLsDueForStatusCheckRow
		if err := rows.Scan(
			&i.UrlID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.LastCheckedAt,
			&i.LastStatusCode,
			&i.GoneAt,
			&i.ArchiveUrl,
			&i.ArchiveCheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordClick = `-- name: RecordClick :one

INSERT INTO clicks (url_id, clicked_at, referrer, referrer_domain, country, user_agent)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, url_id, clicked_at, referrer, referrer_domain, country, user_agent
`

type RecordClickParams struct {
	UrlID          int64     `json:"url_id"`
	ClickedAt      time.Time `json:"clicked_at"`
	Referrer       *string   `json:"referrer"`
	ReferrerDomain *string   `json:"referrer_domain"`
	Country        *string   `json:"country"`
	UserAgent      *string   `json:"user_agent"`
}

type RecordClickRow struct {
	ID             int64     `json:"id"`
	UrlID          int64     `json:"url_id"`
	ClickedAt      time.Time `json:"clicked_at"`
	Referrer       *string   `json:"referrer"`
	ReferrerDomain *string   `json:"referrer_domain"`
	Country        *string   `json:"country"`
	UserAgent      *string   `json:"user_agent"`
}

// ============================================================================
// Click Queries
// ============================================================================
func (q *Queries) RecordClick(ctx context.Context, arg RecordClickParams) (RecordClickRow, error) {
	row := q.queryRow(ctx, q.recordClickStmt, recordClick,
		arg.UrlID,
		arg.ClickedAt,
		arg.Referrer,
		arg.ReferrerDomain,
		arg.Country,
		arg.UserAgent,
	)
	var i RecordClickRow
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.ClickedAt,
		&i.Referrer,
		&i.ReferrerDomain,
		&i.Country,
		&i.UserAgent,
	)
	return i, err
}

const upsertURLStatus = `-- name: UpsertURLStatus :exec
INSERT INTO url_status (
    url_id,
    last_checked_at,
    last_status_code,
    gone_at,
    archive_url,
    archive_checked_at
) VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(url_id) DO UPDATE SET
    last_checked_at = excluded.last_checked_at,
    last_status_code = excluded.last_status_code,
    gone_at = excluded.gone_at,
    archive_url = excluded.archive_url,
    archive_checked_at = excluded.archive_checked_at
`

type UpsertURLStatusParams struct {
	UrlID            int64      `json:"url_id"`
	LastCheckedAt    *time.Time `json:"last_checked_at"`
	LastStatusCode   *int64     `json:"last_status_code"`
	GoneAt           *time.Time `json:"gone_at"`
	ArchiveUrl       *string    `json:"archive_url"`
	ArchiveCheckedAt *time.Time `json:"archive_checked_at"`
}

func (q *Queries) UpsertURLStatus(ctx context.Context, arg UpsertURLStatusParams) error {
	_, err := q.exec(ctx, q.upsertURLStatusStmt, upsertURLStatus,
		arg.UrlID,
		arg.LastCheckedAt,
		arg.LastStatusCode,
		arg.GoneAt,
		arg.ArchiveUrl,
		arg.ArchiveCheckedAt,
	)
	return err
}
